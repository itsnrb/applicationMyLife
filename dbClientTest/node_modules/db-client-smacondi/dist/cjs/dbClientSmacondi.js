"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.closeAllDbClients = closeAllDbClients;
exports.getDbClientSmacondi = getDbClientSmacondi;
var _AccountApi = require("./support/AccountApi.js");
var _dbClient = require("./dbClient.js");
var _logger = _interopRequireDefault(require("./support/logger.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
// @ts-check

/** @type {Record<string, import('./dbClient.js').DbClient>} key is the clusterId string, value the dbClient belonging to the clusterId */
const dbClientCache = {};
/** @type {DbClientSmacondi | null} */
let dbClientSmacondi = null;

/**
 * Gets a singleton dbClient instance, params are only needed during first call
 * @param {Object<string, string>} [connectionStringMap={}] - Object where key is the clusterId and value is the connection string for the cluster
 * @param {string} [apiURL='localhost:5000'] - URL of the account API to get account details
 * @param {number} [readTimeout=30000] - Read timeout in milliseconds
 * @param {number} [writeTimeout=30000] - Write timeout in milliseconds
 * @returns {DbClientSmacondi} - The singleton dbClientSmacondi instance
 * @throws {Error} - If params are missing during first call
 */
function getDbClientSmacondi(connectionStringMap = {}, apiURL = 'localhost:5000', readTimeout = 30000, writeTimeout = 30000) {
  if (dbClientSmacondi === null) {
    _logger.default.info('Creating new instance of DbClientSmacondi');
    dbClientSmacondi = new DbClientSmacondi(connectionStringMap, apiURL, readTimeout, writeTimeout);
  }
  return dbClientSmacondi;
}

/**
 * Closes all active database client connections
 * @returns {Promise<void>}
 */
async function closeAllDbClients() {
  for (const dbClient of Object.values(dbClientCache)) {
    await dbClient.disconnect();
  }
}

/**
 * Private class to create only one instance
 */
class DbClientSmacondi {
  /**
   * Creates a new DbClientSmacondi instance
   * @param {Object<string, string>} connectionStringMap - Object where key is the clusterId and value is the connection string for the cluster
   * @param {string} [apiURL] - URL of the account API to get account details
   * @param {number} [readTimeout] - Read timeout in milliseconds
   * @param {number} [writeTimeout] - Write timeout in milliseconds
   * @throws {Error} - If connectionStringMap is empty, apiURL is invalid, or timeout values are not numbers
   */
  constructor(connectionStringMap, apiURL, readTimeout, writeTimeout) {
    // check connectionStringMap
    if (Object.keys(connectionStringMap).length === 0) {
      throw new Error(`Invalid connectionStringMap: ${connectionStringMap}`);
    } else {
      /** @type {Object<string, string>} */
      this.connectionStringMap = connectionStringMap;
    }
    // check apiUrl
    if (typeof apiURL !== 'string' || apiURL.trim() === '') {
      throw new Error(`Invalid apiURL: ${apiURL}`);
    } else {
      /** @type {AccountApi} */
      this.accountApi = new _AccountApi.AccountApi(apiURL);
    }
    // check if read and write timeout are numbers
    if (typeof readTimeout !== 'number') {
      throw new Error(`Invalid read timeout: ${readTimeout}`);
    } else {
      /** @type {number} */
      this.readTimeout = readTimeout;
    }
    if (typeof writeTimeout !== 'number') {
      throw new Error(`Invalid write timeout: ${writeTimeout}`);
    } else {
      /** @type {number} */
      this.writeTimeout = writeTimeout;
    }
  }

  /**
   * Gets a dbClient instance which can connect to the account database and returns the name of the account database
   * @param {String} accountId - The ID of the account to get the database for
   * @returns {Promise<{ dbClient: import('./dbClient.js').DbClient, dbName: String, _id: String }>} - An object containing the dbClient, the db name, and the account id
   * @throws {Error} - If accountId is missing or no connection string is found for the cluster
   */
  async getDbClientByAccountId(accountId) {
    if (!accountId) {
      throw new Error('missing args');
    }
    const {
      clusterId,
      dbName
    } = await this.accountApi.getAccountById(accountId);
    const accountConnStr = this.connectionStringMap[clusterId];
    if (!accountConnStr) {
      throw new Error(`No connection string found for cluster ${clusterId}`);
    }
    let accountDbClient = dbClientCache[clusterId];
    if (!accountDbClient) {
      const newAccountDbClient = new _dbClient.DbClient(accountConnStr, this.readTimeout, this.writeTimeout);
      dbClientCache[clusterId] = newAccountDbClient;
      accountDbClient = newAccountDbClient;
    }
    return {
      dbClient: accountDbClient,
      dbName: dbName,
      _id: accountId
    };
  }

  /**
   * Returns the db client for the given clusterId
   * @param {string} [clusterId='MAIN'] - The ID of the cluster to get the client for
   * @returns {import('./dbClient.js').DbClient} - The database client for the specified cluster
   * @throws {Error} - If no connection string is found for the cluster
   */
  getDbClientByClusterId(clusterId = 'MAIN') {
    const connectionString = this.connectionStringMap[clusterId];
    if (!connectionString) {
      throw new Error(`No connection string found for cluster ${clusterId}`);
    }
    let dbClient = dbClientCache[clusterId];
    if (!dbClient) {
      dbClient = new _dbClient.DbClient(connectionString, this.readTimeout, this.writeTimeout);
      dbClientCache[clusterId] = dbClient;
    }
    return dbClient;
  }
}