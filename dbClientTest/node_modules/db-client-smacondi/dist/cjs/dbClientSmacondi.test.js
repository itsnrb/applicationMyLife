"use strict";

var _vitest = require("vitest");
var _dbClientSmacondi = require("./dbClientSmacondi.js");
var _AccountApi = require("./support/AccountApi.js");
var _dbClient = require("./dbClient.js");
// Mock dependencies
_vitest.vi.mock('./support/AccountApi.js');
_vitest.vi.mock('./dbClient.js');
_vitest.vi.mock('./support/logger.js', () => ({
  default: {
    info: _vitest.vi.fn(),
    error: _vitest.vi.fn(),
    warn: _vitest.vi.fn()
  }
}));
(0, _vitest.describe)('DbClientSmacondi', () => {
  (0, _vitest.beforeEach)(() => {
    // Reset mocks
    _vitest.vi.clearAllMocks();

    // Reset module cache between tests
    _vitest.vi.resetModules();

    // Mock the AccountApi methods
    _AccountApi.AccountApi.prototype.getAccountById = _vitest.vi.fn().mockResolvedValue({
      _id: '123',
      dbName: 'testDb',
      clusterId: 'cluster1'
    });

    // Mock DbClient
    _dbClient.DbClient.prototype.findOne = _vitest.vi.fn().mockResolvedValue({
      _id: '123',
      name: 'test'
    });
    _dbClient.DbClient.prototype.find = _vitest.vi.fn().mockResolvedValue([{
      _id: '123',
      name: 'test'
    }]);
    _dbClient.DbClient.prototype.connect = _vitest.vi.fn().mockResolvedValue();
  });
  (0, _vitest.afterEach)(async () => {
    // Reset the singleton
    await (0, _dbClientSmacondi.closeAllDbClients)();
  });
  (0, _vitest.describe)('getDbClientSmacondi', () => {
    (0, _vitest.it)('should create a new instance when called for the first time', () => {
      const connectionMap = {
        cluster1: 'mongodb://localhost:27017'
      };
      const client = (0, _dbClientSmacondi.getDbClientSmacondi)(connectionMap, 'http://api.example.com');
      (0, _vitest.expect)(client).toBeDefined();
      (0, _vitest.expect)(client.constructor.name).toBe('DbClientSmacondi');
    });
    (0, _vitest.it)('should return the existing instance on subsequent calls', () => {
      const connectionMap = {
        cluster1: 'mongodb://localhost:27017'
      };
      const firstInstance = (0, _dbClientSmacondi.getDbClientSmacondi)(connectionMap, 'http://api.example.com');
      const secondInstance = (0, _dbClientSmacondi.getDbClientSmacondi)();
      (0, _vitest.expect)(secondInstance).toBe(firstInstance);
    });
  });
  (0, _vitest.describe)('DbClientSmacondi methods', () => {
    (0, _vitest.it)('should initialize with connection strings and API URL', () => {
      const connectionMap = {
        cluster1: 'mongodb://localhost:27017'
      };
      const client = (0, _dbClientSmacondi.getDbClientSmacondi)(connectionMap, 'http://api.example.com', 30000, 30000);

      // Use toEqual instead of toBe for object comparison
      (0, _vitest.expect)(client.connectionStringMap).toEqual(connectionMap);
      (0, _vitest.expect)(client.accountApi).toBeDefined();
    });
    (0, _vitest.it)('should get a DB client for a cluster', async () => {
      const connectionMap = {
        cluster1: 'mongodb://localhost:27017'
      };
      const client = (0, _dbClientSmacondi.getDbClientSmacondi)(connectionMap, 'http://api.example.com', 30000, 30000);
      const dbClient = client.getDbClientByClusterId('cluster1');
      (0, _vitest.expect)(dbClient).toBeInstanceOf(_dbClient.DbClient);
    });
    (0, _vitest.it)('should throw an error if connection string for cluster is not found', () => {
      const connectionMap = {
        cluster1: 'mongodb://localhost:27017'
      };
      const client = (0, _dbClientSmacondi.getDbClientSmacondi)(connectionMap, 'http://api.example.com', 30000, 30000);
      (0, _vitest.expect)(() => client.getDbClientByClusterId('nonexistent')).toThrow();
    });
    (0, _vitest.it)('should get account info and DB client by account ID', async () => {
      // Instead of trying to test with a spy, let's test the integration directly
      // Clear modules and singleton for a clean test
      await (0, _dbClientSmacondi.closeAllDbClients)();
      _vitest.vi.resetModules();

      // Create a fresh client with our mocked dependencies
      const client = (0, _dbClientSmacondi.getDbClientSmacondi)({
        cluster1: 'mongodb://localhost:27017'
      }, 'http://api.example.com', 30000, 30000);

      // Spy on the accountApi instance that was created
      const apiSpy = _vitest.vi.spyOn(client.accountApi, 'getAccountById');

      // Call the method
      const result = await client.getDbClientByAccountId('123');

      // Check the result
      (0, _vitest.expect)(result).toHaveProperty('dbClient');
      (0, _vitest.expect)(result).toHaveProperty('dbName', 'testDb');
      (0, _vitest.expect)(result).toHaveProperty('_id', '123');

      // Verify the account API was called with the right ID
      (0, _vitest.expect)(apiSpy).toHaveBeenCalledWith('123');
    });
    (0, _vitest.it)('should get DB client by account ID for database operations', async () => {
      const client = (0, _dbClientSmacondi.getDbClientSmacondi)({
        cluster1: 'mongodb://localhost:27017'
      }, 'http://api.example.com', 30000, 30000);

      // Create a spy for the getDbClientByAccountId method
      const spy = _vitest.vi.spyOn(client, 'getDbClientByAccountId').mockResolvedValue({
        dbClient: new _dbClient.DbClient('connection-string'),
        dbName: 'testDb',
        _id: '123'
      });

      // Test that the method works as expected
      const result = await client.getDbClientByAccountId('123');
      (0, _vitest.expect)(spy).toHaveBeenCalledWith('123');
      (0, _vitest.expect)(result.dbClient).toBeInstanceOf(_dbClient.DbClient);
      (0, _vitest.expect)(result.dbName).toBe('testDb');
    });
  });
  (0, _vitest.describe)('closeAllDbClients', () => {
    (0, _vitest.it)('should close all DB clients', async () => {
      // Mock the DbClient disconnect method
      const disconnectMock = _vitest.vi.fn().mockResolvedValue();

      // Create a mock DB client that will be stored in the cache
      const mockDbClient = {
        disconnect: disconnectMock
      };

      // Directly manipulate the dbClientCache
      _vitest.vi.doMock('./dbClientSmacondi.js', async importOriginal => {
        const original = await importOriginal();

        // Add our mock client to the cache
        global.dbClientCache = {
          'mock-cluster': mockDbClient
        };
        return {
          ...original,
          // Make sure closeAllDbClients accesses our mock cache
          closeAllDbClients: async () => {
            for (const client of Object.values(global.dbClientCache)) {
              await client.disconnect();
            }
          }
        };
      });
    });
  });
});