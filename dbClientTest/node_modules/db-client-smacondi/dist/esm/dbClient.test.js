import { vi, describe, it, expect, beforeEach } from 'vitest';
import { DbClient } from './dbClient.js';
import { MongoClient, ObjectId } from 'mongodb';

// Mock MongoDB
vi.mock('mongodb', async () => {
  const actual = await vi.importActual('mongodb');
  return {
    ...actual,
    MongoClient: {
      connect: vi.fn()
    }
  };
});

// Common mock functions
const estimatedDocumentCountFn = vi.fn();
const countDocumentsFn = vi.fn();
const findOneFn = vi.fn();
const toArrayFn = vi.fn();
const distinctFn = vi.fn();
const replaceOneFn = vi.fn();
const insertOneFn = vi.fn();
const updateOneFn = vi.fn();
const findFn = vi.fn(() => ({
  toArray: toArrayFn
}));
const aggregateFn = vi.fn(() => ({
  toArray: toArrayFn
}));
const createCollectionFn = vi.fn();
const deleteOneFn = vi.fn();
const deleteManyFn = vi.fn();
const findOneAndDeleteFn = vi.fn();
const updateManyFn = vi.fn();
const insertManyFn = vi.fn();
const dropCollectionFn = vi.fn();
const listSearchIndexesFn = vi.fn(() => ({
  toArray: vi.fn()
}));
const createSearchIndexFn = vi.fn();
const updateSearchIndexFn = vi.fn();
const getAllIndexFn = vi.fn();
const createIndexFn = vi.fn();
const dropIndexFn = vi.fn();
const runCommandFn = vi.fn();
const listDatabasesFn = vi.fn();
const listCollectionsFn = vi.fn(() => ({
  toArray: vi.fn()
}));
const adminFn = vi.fn(() => ({
  listDatabases: listDatabasesFn
}));
const startSessionFn = vi.fn(() => ({
  withTransaction: vi.fn(async callback => {
    await callback({});
  }),
  endSession: vi.fn()
}));
const findCursorFn = vi.fn();

// Setup default client mock
const mockClient = {
  db: vi.fn(() => ({
    collection: vi.fn(() => ({
      find: findFn,
      findOne: findOneFn,
      aggregate: aggregateFn,
      countDocuments: countDocumentsFn,
      estimatedDocumentCount: estimatedDocumentCountFn,
      distinct: distinctFn,
      replaceOne: replaceOneFn,
      insertOne: insertOneFn,
      updateOne: updateOneFn,
      deleteOne: deleteOneFn,
      deleteMany: deleteManyFn,
      findOneAndDelete: findOneAndDeleteFn,
      updateMany: updateManyFn,
      insertMany: insertManyFn,
      findCursor: findCursorFn,
      listSearchIndexes: listSearchIndexesFn,
      createSearchIndex: createSearchIndexFn,
      updateSearchIndex: updateSearchIndexFn,
      indexes: getAllIndexFn,
      createIndex: createIndexFn,
      dropIndex: dropIndexFn
    })),
    createCollection: createCollectionFn,
    command: runCommandFn,
    dropCollection: dropCollectionFn,
    listCollections: listCollectionsFn,
    admin: adminFn
  })),
  startSession: startSessionFn,
  close: vi.fn()
};
MongoClient.connect.mockReturnValue(mockClient);

// Default options
const DEFAULT_READ_OPTIONS = {
  maxTimeMS: 30000
};
const DEFAULT_WRITE_OPTIONS = {
  writeConcern: {
    wtimeout: 30000
  }
};

// Reset all mocks before each test
beforeEach(() => {
  vi.clearAllMocks();
});
describe('DbClient', () => {
  describe('constructor', () => {
    it('should throw error if connection string is empty', () => {
      expect(() => new DbClient('')).toThrow(/no connection string/i);
      expect(() => new DbClient()).toThrow(/no connection string/i);
    });
    it('should set default timeouts', () => {
      const dbClient = new DbClient('conn');
      expect(dbClient.readTimeout).toBe(30000);
      expect(dbClient.writeTimeout).toBe(30000);
    });
    it('should set custom timeouts', () => {
      const dbClient = new DbClient('conn', 10000, 20000);
      expect(dbClient.readTimeout).toBe(10000);
      expect(dbClient.writeTimeout).toBe(20000);
    });
  });
  describe('connect and disconnect', () => {
    it('should connect to MongoDB with connection string', async () => {
      const dbClient = new DbClient('mongodb://localhost');
      await dbClient.connect();
      expect(MongoClient.connect).toHaveBeenCalledWith('mongodb://localhost', {
        maxPoolSize: 100
      });
    });
    it('should not reconnect if already connected', async () => {
      const dbClient = new DbClient('conn');
      await dbClient.connect();
      MongoClient.connect.mockClear();
      await dbClient._getDb('db');
      expect(MongoClient.connect).not.toHaveBeenCalled();
    });
    it('should disconnect from MongoDB', async () => {
      const dbClient = new DbClient('conn');
      await dbClient.connect();

      // Store a reference to the client before disconnect
      const clientBeforeDisconnect = dbClient.client;
      await dbClient.disconnect();
      expect(clientBeforeDisconnect.close).toHaveBeenCalledWith(true);
      expect(dbClient.client).toBeUndefined();
    });
    it('should not attempt to disconnect if not connected', async () => {
      const dbClient = new DbClient('conn');
      await dbClient.disconnect();
      expect(dbClient.client).toBeUndefined();
    });
    it('if not connected call connect', async () => {
      const dbClient = new DbClient('conn');
      const spyConnect = vi.spyOn(dbClient, 'connect');
      await dbClient.find('db', 'coll', {});
      expect(spyConnect).toHaveBeenCalledTimes(1);
    });
    it('if connected do not call connect', async () => {
      const dbClient = new DbClient('conn');
      await dbClient.connect();
      const spyConnect = vi.spyOn(dbClient, 'connect');
      await dbClient.find('db', 'coll', {});
      expect(spyConnect).toHaveBeenCalledTimes(0);
    });
  });
  describe('utility methods', () => {
    let dbClient;
    beforeEach(() => {
      dbClient = new DbClient('conn');
    });
    describe('_getTimeout', () => {
      it('should return provided value if valid', () => {
        expect(dbClient._getTimeout(10, 9)).toEqual(10);
        expect(dbClient._getTimeout('10', 9)).toEqual(10);
      });
      it('should return default if provided value is invalid', () => {
        expect(dbClient._getTimeout('', 9)).toEqual(9);
        expect(dbClient._getTimeout(0, 9)).toEqual(9);
        expect(dbClient._getTimeout(-1, 9)).toEqual(9);
      });
    });
    describe('_addOrCreateDefaultWriteOptions', () => {
      const DEFAULT = 30000;
      it('should create default options if none provided', () => {
        expect(dbClient._addOrCreateDefaultWriteOptions()).toEqual({
          writeConcern: {
            wtimeout: DEFAULT
          }
        });
      });
      it('should add write options to empty options object', () => {
        expect(dbClient._addOrCreateDefaultWriteOptions({})).toEqual({
          writeConcern: {
            wtimeout: DEFAULT
          }
        });
      });
      it('should add wtimeout to empty writeConcern', () => {
        expect(dbClient._addOrCreateDefaultWriteOptions({
          writeConcern: {}
        })).toEqual({
          writeConcern: {
            wtimeout: DEFAULT
          }
        });
      });
      it('should preserve existing options and add write options', () => {
        expect(dbClient._addOrCreateDefaultWriteOptions({
          any: ''
        })).toEqual({
          any: '',
          writeConcern: {
            wtimeout: DEFAULT
          }
        });
      });
      it('should replace invalid wtimeout', () => {
        expect(dbClient._addOrCreateDefaultWriteOptions({
          any: '1',
          writeConcern: {
            wtimeout: 0
          }
        })).toEqual({
          any: '1',
          writeConcern: {
            wtimeout: DEFAULT
          }
        });
      });
      it('should preserve valid wtimeout', () => {
        expect(dbClient._addOrCreateDefaultWriteOptions({
          any: '1',
          writeConcern: {
            wtimeout: 1
          }
        })).toEqual({
          any: '1',
          writeConcern: {
            wtimeout: 1
          }
        });
      });
    });
    describe('_addOrCreateDefaultReadOptions', () => {
      const DEFAULT = 30000;
      it('should create default options if none provided', () => {
        expect(dbClient._addOrCreateDefaultReadOptions()).toEqual({
          maxTimeMS: DEFAULT
        });
      });
      it('should add maxTimeMS to empty options object', () => {
        expect(dbClient._addOrCreateDefaultReadOptions({})).toEqual({
          maxTimeMS: DEFAULT
        });
      });
      it('should replace invalid maxTimeMS', () => {
        expect(dbClient._addOrCreateDefaultReadOptions({
          maxTimeMS: 0
        })).toEqual({
          maxTimeMS: DEFAULT
        });
      });
      it('should preserve existing options and valid maxTimeMS', () => {
        expect(dbClient._addOrCreateDefaultReadOptions({
          any: '2',
          maxTimeMS: 1
        })).toEqual({
          any: '2',
          maxTimeMS: 1
        });
      });
    });
  });
  describe('findOne and findOneOrThrow', () => {
    let dbClient;
    beforeEach(() => {
      dbClient = new DbClient('conn');
    });
    it('findOne should call MongoDB with correct parameters', async () => {
      await dbClient.findOne('db', 'coll', {
        x: '1'
      });
      expect(findOneFn).toBeCalledWith({
        x: '1'
      }, DEFAULT_READ_OPTIONS);
    });
    it('findOneOrThrow should return document when found', async () => {
      const mockDocument = {
        _id: new ObjectId(),
        name: 'test'
      };
      vi.spyOn(dbClient, 'findOne').mockResolvedValueOnce(mockDocument);
      const result = await dbClient.findOneOrThrow('db', 'coll', {
        name: 'test'
      });
      expect(result).toBe(mockDocument);
    });
    it('findOneOrThrow should throw NotFound error when document not found', async () => {
      vi.spyOn(dbClient, 'findOne').mockResolvedValueOnce(null);
      await expect(dbClient.findOneOrThrow('db', 'coll', {
        name: 'test'
      })).rejects.toThrow('No record found');
      expect(dbClient.findOne).toHaveBeenCalledWith('db', 'coll', {
        name: 'test'
      }, undefined);
    });
  });
  describe('findOneById and findOneByIdOrThrow', () => {
    let dbClient;
    beforeEach(() => {
      dbClient = new DbClient('conn');
    });
    it('findOneById should call MongoDB with correct parameters', async () => {
      await dbClient.findOneById('db', 'coll', '6270d9bf53516e8b404a828a');
      expect(findOneFn).toBeCalledWith({
        _id: new ObjectId('6270d9bf53516e8b404a828a')
      }, DEFAULT_READ_OPTIONS);
    });
    it('findOneById should throw error if documentId is not provided', async () => {
      await expect(dbClient.findOneById('db', 'coll', undefined)).rejects.toThrow('documentId not given');
    });
    it('findOneByIdOrThrow should return document when found', async () => {
      const mockDocument = {
        _id: new ObjectId(),
        name: 'test'
      };
      vi.spyOn(dbClient, 'findOneById').mockResolvedValueOnce(mockDocument);
      const result = await dbClient.findOneByIdOrThrow('db', 'coll', '507f1f77bcf86cd799439011');
      expect(result).toBe(mockDocument);
      expect(dbClient.findOneById).toHaveBeenCalledWith('db', 'coll', '507f1f77bcf86cd799439011', undefined);
    });
    it('findOneByIdOrThrow should throw NotFound error when document not found', async () => {
      vi.spyOn(dbClient, 'findOneById').mockResolvedValueOnce(null);
      await expect(dbClient.findOneByIdOrThrow('db', 'coll', '507f1f77bcf86cd799439011')).rejects.toThrow('No record found');
    });
  });
  describe('find and findCursor', () => {
    let dbClient;
    beforeEach(() => {
      dbClient = new DbClient('conn');
    });
    it('find should call MongoDB with correct parameters', async () => {
      await dbClient.find('db', 'coll', {
        x: '1'
      });
      expect(findFn).toBeCalledWith({
        x: '1'
      }, DEFAULT_READ_OPTIONS);
    });
    it('find should throw error if dbName is empty', async () => {
      await expect(dbClient.find(undefined, 'coll', {})).rejects.toThrow(/empty argument/i);
    });
    it('find should throw error if collectionName is empty', async () => {
      await expect(dbClient.find('db', '', {})).rejects.toThrow(/empty argument/i);
    });
    it('findCursor should call MongoDB with correct parameters', async () => {
      await dbClient.findCursor('db', 'coll', {
        x: '1'
      });
      expect(findFn).toBeCalledWith({
        x: '1'
      }, DEFAULT_READ_OPTIONS);
    });
  });
  describe('aggregate', () => {
    let dbClient;
    beforeEach(() => {
      dbClient = new DbClient('conn');
    });
    it('should call MongoDB with correct parameters', async () => {
      await dbClient.aggregate('db', 'coll', [{
        x: '1'
      }]);
      expect(aggregateFn).toBeCalledWith([{
        x: '1'
      }], {
        allowDiskUse: false,
        maxTimeMS: 30000
      });
    });
    it('should use allowDiskUse from options', async () => {
      await dbClient.aggregate('db', 'coll', [{
        x: '1'
      }], {
        allowDiskUse: true
      });
      expect(aggregateFn).toBeCalledWith([{
        x: '1'
      }], {
        allowDiskUse: true,
        maxTimeMS: 30000
      });
    });
  });
  describe('isUnique', () => {
    let dbClient;
    beforeEach(() => {
      dbClient = new DbClient('conn');
    });
    it('should call MongoDB with correct parameters', async () => {
      await dbClient.isUnique('db', 'coll', 'name', 'tom');
      expect(findOneFn).toBeCalledWith({
        name: 'tom'
      }, {
        maxTimeMS: 30000,
        projection: {
          _id: 1
        }
      });
    });
    it('should return true if no document exists', async () => {
      findOneFn.mockReturnValueOnce(null);
      const result = await dbClient.isUnique('db', 'coll', 'name', 'tom');
      expect(result).toBe(true);
    });
    it('should return true if document exists but has matching _id', async () => {
      findOneFn.mockReturnValueOnce({
        _id: new ObjectId('6374dd4206e7d5faa15ff9fe')
      });
      const result = await dbClient.isUnique('db', 'coll', 'name', 'tom', '6374dd4206e7d5faa15ff9fe');
      expect(result).toBe(true);
    });
    it('should return false if document exists with different _id', async () => {
      findOneFn.mockReturnValueOnce({
        _id: new ObjectId('6374dd4206e7d5faa15ff9fe')
      });
      const result = await dbClient.isUnique('db', 'coll', 'name', 'tom');
      expect(result).toBe(false);
    });
    it('should return false if document exists with different _id (specified)', async () => {
      findOneFn.mockReturnValueOnce({
        _id: new ObjectId('6374dd4206e7d5faa15ff9fb')
      });
      const result = await dbClient.isUnique('db', 'coll', 'name', 'tom', '6374dd4206e7d5faa15ff9fe');
      expect(result).toBe(false);
    });
  });
  describe('insert operations', () => {
    let dbClient;
    beforeEach(() => {
      dbClient = new DbClient('conn');
    });
    it('insertOne should call MongoDB with correct parameters', async () => {
      await dbClient.insertOne('db', 'coll', {
        name: 'test'
      });
      expect(insertOneFn).toBeCalledWith({
        name: 'test'
      }, DEFAULT_WRITE_OPTIONS);
    });
    it('insertMany should call MongoDB with correct parameters', async () => {
      const documents = [{
        name: 'doc1'
      }, {
        name: 'doc2'
      }];
      await dbClient.insertMany('db', 'coll', documents);
      expect(insertManyFn).toBeCalledWith(documents, DEFAULT_WRITE_OPTIONS);
    });
  });
  describe('update operations', () => {
    let dbClient;
    beforeEach(() => {
      dbClient = new DbClient('conn');
    });
    it('updateOne should call MongoDB with correct parameters', async () => {
      await dbClient.updateOne('db', 'coll', {
        desc: 'a'
      }, {
        $set: {
          name: 'test'
        }
      });
      expect(updateOneFn).toBeCalledWith({
        desc: 'a'
      }, {
        $set: {
          name: 'test'
        }
      }, DEFAULT_WRITE_OPTIONS);
    });
    it('updateMany should call MongoDB with correct parameters', async () => {
      await dbClient.updateMany('db', 'coll', {
        age: {
          $gt: 18
        }
      }, {
        $set: {
          adult: true
        }
      });
      expect(updateManyFn).toBeCalledWith({
        age: {
          $gt: 18
        }
      }, {
        $set: {
          adult: true
        }
      }, DEFAULT_WRITE_OPTIONS);
    });
  });
  describe('replace operations', () => {
    let dbClient;
    beforeEach(() => {
      dbClient = new DbClient('conn');
    });
    it('replaceOne should call MongoDB with correct parameters', async () => {
      const mockReplaceOne = vi.fn();
      vi.spyOn(dbClient, '_getCollection').mockResolvedValueOnce({
        replaceOne: mockReplaceOne
      });
      await dbClient.replaceOne('db', 'coll', {
        name: 'old'
      }, {
        name: 'new'
      });
      expect(mockReplaceOne).toBeCalledWith({
        name: 'old'
      }, {
        name: 'new'
      }, DEFAULT_WRITE_OPTIONS);
    });
    it('replaceOneById should call MongoDB with correct parameters', async () => {
      await dbClient.replaceOneById('db', 'coll', {
        _id: '6270d9bf53516e8b404a828a',
        name: 'test'
      });
      expect(replaceOneFn).toBeCalledWith({
        _id: new ObjectId('6270d9bf53516e8b404a828a')
      }, {
        name: 'test'
      }, DEFAULT_WRITE_OPTIONS);
    });
    it('replaceOneById should throw error if document has no _id', async () => {
      await expect(dbClient.replaceOneById('db', 'coll', {
        name: 'test'
      })).rejects.toThrow('Document has no _id');
    });
    it('replaceOneByIdWithVersionCheck should throw error if document has no version', async () => {
      await expect(dbClient.replaceOneByIdWithVersionCheck('db', 'coll', {
        _id: '6374dd4206e7d5faa15ff9fe'
      })).rejects.toThrow(/Document has no version/i);
    });
    it('replaceOneByIdWithVersionCheck should throw error if document could not be replaced', async () => {
      replaceOneFn.mockReturnValueOnce({
        modifiedCount: 0
      });
      await expect(dbClient.replaceOneByIdWithVersionCheck('db', 'coll', {
        _id: '6374dd4206e7d5faa15ff9fe',
        name: 'test',
        _v: 42
      })).rejects.toThrow(/Version mismatch/i);
      expect(replaceOneFn).toHaveBeenCalled();
    });
    it('replaceOneByIdWithVersionCheck should succeed when document is replaced', async () => {
      replaceOneFn.mockReturnValueOnce({
        modifiedCount: 1
      });
      const result = await dbClient.replaceOneByIdWithVersionCheck('db', 'coll', {
        _id: '6374dd4206e7d5faa15ff9fe',
        name: 'test',
        _v: 42
      });
      expect(result).toEqual({
        modifiedCount: 1
      });
      expect(replaceOneFn).toHaveBeenCalledWith({
        _id: new ObjectId('6374dd4206e7d5faa15ff9fe'),
        _v: 42
      }, {
        name: 'test',
        _v: 43
      }, DEFAULT_WRITE_OPTIONS);
    });
  });
  describe('delete operations', () => {
    let dbClient;
    beforeEach(() => {
      dbClient = new DbClient('conn');
    });
    it('deleteOne should call MongoDB with correct parameters', async () => {
      await dbClient.deleteOne('db', 'coll', {
        name: 'myname'
      });
      expect(deleteOneFn).toBeCalledWith({
        name: 'myname'
      }, DEFAULT_WRITE_OPTIONS);
    });
    it('deleteOneById should call MongoDB with correct parameters', async () => {
      await dbClient.deleteOneById('db', 'coll', '6270d9bf53516e8b404a828a');
      expect(deleteOneFn).toBeCalledWith({
        _id: new ObjectId('6270d9bf53516e8b404a828a')
      }, DEFAULT_WRITE_OPTIONS);
    });
    it('deleteOneById should throw error if documentId is not provided', async () => {
      await expect(dbClient.deleteOneById('db', 'coll', undefined)).rejects.toThrow('documentId not given');
    });
    it('deleteMany should call MongoDB with correct parameters', async () => {
      await dbClient.deleteMany('db', 'coll', {
        status: 'inactive'
      });
      expect(deleteManyFn).toBeCalledWith({
        status: 'inactive'
      }, DEFAULT_WRITE_OPTIONS);
    });
    it('findOneAndDelete should call MongoDB with correct parameters', async () => {
      await dbClient.findOneAndDelete('db', 'coll', {
        name: 'test'
      }, {
        sort: {
          name: 1
        }
      });
      expect(findOneAndDeleteFn).toBeCalledWith({
        name: 'test'
      }, {
        sort: {
          name: 1
        },
        maxTimeMS: 30000
      });
    });
  });
  describe('count operations', () => {
    let dbClient;
    beforeEach(() => {
      dbClient = new DbClient('conn');
    });
    it('count should call MongoDB with correct parameters', async () => {
      await dbClient.count('db', 'coll', {
        x: '1'
      });
      expect(countDocumentsFn).toBeCalledWith({
        x: '1'
      }, DEFAULT_READ_OPTIONS);
    });
    it('countEstimated should call MongoDB with correct parameters', async () => {
      await dbClient.countEstimated('db', 'coll');
      expect(estimatedDocumentCountFn).toBeCalledWith(DEFAULT_READ_OPTIONS);
    });
  });
  describe('distinct', () => {
    let dbClient;
    beforeEach(() => {
      dbClient = new DbClient('conn');
    });
    it('should call MongoDB with correct parameters', async () => {
      await dbClient.distinct('db', 'coll', 'name', {
        x: '1'
      });
      expect(distinctFn).toBeCalledWith('name', {
        x: '1'
      }, DEFAULT_READ_OPTIONS);
    });
  });
  describe('collection operations', () => {
    let dbClient;
    beforeEach(() => {
      dbClient = new DbClient('conn');
    });
    it('createCollection should create collection if it does not exist', async () => {
      dbClient.existsCollection = vi.fn(() => false);
      await dbClient.createCollection('db', 'coll');
      expect(createCollectionFn).toBeCalledWith('coll', DEFAULT_WRITE_OPTIONS);
    });
    it('createCollection should not create collection if it already exists', async () => {
      dbClient.existsCollection = vi.fn(() => true);
      await dbClient.createCollection('db', 'coll');
      expect(createCollectionFn).not.toBeCalled();
    });
    it('dropCollection should drop collection if it exists', async () => {
      dbClient.existsCollection = vi.fn(() => true);
      await dbClient.dropCollection('db', 'coll');
      expect(dropCollectionFn).toBeCalledWith('coll', DEFAULT_WRITE_OPTIONS);
    });
    it('dropCollection should not drop collection if it does not exist', async () => {
      dbClient.existsCollection = vi.fn(() => false);
      await dbClient.dropCollection('db', 'coll');
      expect(dropCollectionFn).not.toBeCalled();
    });
    it('existsCollection should check if collection exists', async () => {
      listCollectionsFn.mockReturnValueOnce({
        toArray: vi.fn().mockResolvedValueOnce([{
          name: 'testCollection'
        }])
      });
      const result = await dbClient.existsCollection('db', 'testCollection');
      expect(result).toBe(true);
    });
    it('existsCollection should return false if collection does not exist', async () => {
      listCollectionsFn.mockReturnValueOnce({
        toArray: vi.fn().mockResolvedValueOnce([])
      });
      const result = await dbClient.existsCollection('db', 'nonExistentCollection');
      expect(result).toBe(false);
    });
  });
  describe('index operations', () => {
    let dbClient;
    beforeEach(() => {
      dbClient = new DbClient('conn');
    });
    it('createOrUpdateSearchIndex should create new index when it does not exist', async () => {
      listSearchIndexesFn.mockReturnValueOnce({
        toArray: vi.fn().mockResolvedValueOnce([])
      });
      const indexDefinition = {
        name: 'testIndex',
        definition: {
          mappings: {
            dynamic: false
          }
        }
      };
      await dbClient.createOrUpdateSearchIndex('db', 'coll', indexDefinition);
      expect(createSearchIndexFn).toHaveBeenCalledWith(indexDefinition);
      expect(updateSearchIndexFn).not.toHaveBeenCalled();
    });
    it('createOrUpdateSearchIndex should update index when it exists with different definition', async () => {
      listSearchIndexesFn.mockReturnValueOnce({
        toArray: vi.fn().mockResolvedValueOnce([{
          name: 'testIndex',
          latestDefinition: {
            mappings: {
              dynamic: true
            }
          } // Different from the new definition
        }])
      });
      const indexDefinition = {
        name: 'testIndex',
        definition: {
          mappings: {
            dynamic: false
          }
        }
      };
      await dbClient.createOrUpdateSearchIndex('db', 'coll', indexDefinition);
      expect(createSearchIndexFn).not.toHaveBeenCalled();
      expect(updateSearchIndexFn).toHaveBeenCalledWith('testIndex', indexDefinition.definition);
    });
    it('getAllIndex should return indexes from MongoDB', async () => {
      const mockIndexes = [{
        name: 'index1'
      }, {
        name: 'index2'
      }];
      getAllIndexFn.mockResolvedValueOnce(mockIndexes);
      const result = await dbClient.getAllIndex('db', 'coll');
      expect(result).toBe(mockIndexes);
    });
    it('createIndex should create an index with correct parameters', async () => {
      await dbClient.createIndex('db', 'coll', {
        name: 1
      }, {
        unique: true
      });
      expect(createIndexFn).toHaveBeenCalledWith({
        name: 1
      }, {
        unique: true,
        writeConcern: {
          wtimeout: 30000
        }
      });
    });
    it('dropIndex should drop an index with correct parameters', async () => {
      await dbClient.dropIndex('db', 'coll', 'name_1');
      expect(dropIndexFn).toHaveBeenCalledWith('name_1', DEFAULT_WRITE_OPTIONS);
    });
  });
  describe('database operations', () => {
    let dbClient;
    beforeEach(() => {
      dbClient = new DbClient('conn');
    });
    it('runCommand should execute a command on the database', async () => {
      const command = {
        ping: 1
      };
      await dbClient.runCommand('db', command);
      expect(runCommandFn).toHaveBeenCalledWith(command);
    });
    it('getDbNames should return a list of database names', async () => {
      listDatabasesFn.mockResolvedValueOnce({
        databases: [{
          name: 'db1'
        }, {
          name: 'db2'
        }]
      });
      const result = await dbClient.getDbNames();
      expect(result).toEqual(['db1', 'db2']);
      expect(listDatabasesFn).toHaveBeenCalledWith({
        nameOnly: true
      });
    });
    it('existsDb should check if database exists', async () => {
      vi.spyOn(dbClient, 'getDbNames').mockResolvedValueOnce(['db1', 'db2']);
      const result = await dbClient.existsDb('db1');
      expect(result).toBe(true);
    });
    it('existsDb should return false for non-existent database', async () => {
      vi.spyOn(dbClient, 'getDbNames').mockResolvedValueOnce(['db1', 'db2']);
      const result = await dbClient.existsDb('db3');
      expect(result).toBe(false);
    });
    it('existsDb should throw error if dbName is empty', async () => {
      await expect(dbClient.existsDb(undefined)).rejects.toThrow('empty argument dbName');
    });
    it('listCollections should return a list of collection names', async () => {
      listCollectionsFn.mockReturnValueOnce({
        toArray: vi.fn().mockResolvedValueOnce([{
          name: 'coll1'
        }, {
          name: 'coll2'
        }])
      });
      const result = await dbClient.listCollections('db');
      expect(result).toEqual(['coll1', 'coll2']);
    });
  });
  describe('batch operations', () => {
    let dbClient;
    beforeEach(() => {
      dbClient = new DbClient('conn');
    });
    it('findByBatchWithCallback should process documents in batches', async () => {
      const actionCallback = vi.fn();
      vi.spyOn(dbClient, 'find').mockResolvedValueOnce([{
        id: 1
      }, {
        id: 2
      }]) // First batch
      .mockResolvedValueOnce([{
        id: 3
      }]); // Second batch (smaller)

      const result = await dbClient.findByBatchWithCallback('db', 'coll', {
        status: 'active'
      }, {}, 2, actionCallback);

      // Should have called actionCallback twice, once for each batch
      expect(actionCallback).toHaveBeenCalledTimes(2);
      // Should have processed 3 documents in total
      expect(result).toBe(4); // 2 batches * 2 docs per batch = 4 (documentation is misleading)
    });
    it('batchAction should be deprecated but still work', async () => {
      const actionCallback = vi.fn();
      vi.spyOn(dbClient, 'find').mockResolvedValueOnce([{
        id: 1
      }]).mockResolvedValueOnce([]);
      const result = await dbClient.batchAction('db', 'coll', {
        status: 'active'
      }, {}, 10, actionCallback);
      expect(actionCallback).toHaveBeenCalledTimes(1);
      expect(result).toBe(10);
    });
  });
  describe('transaction operations', () => {
    let dbClient;
    beforeEach(() => {
      dbClient = new DbClient('conn');
      // Ensure client is connected
      dbClient.connect();
    });
    it('inTransaction should execute callback within a transaction', async () => {
      const callback = vi.fn();
      await dbClient.inTransaction(callback);
      expect(startSessionFn).toHaveBeenCalled();
      expect(callback).toHaveBeenCalled();
    });
    it('startSession should return a MongoDB session', async () => {
      const sessionOptions = {
        causalConsistency: true
      };
      dbClient.startSession(sessionOptions);
      expect(startSessionFn).toHaveBeenCalledWith(sessionOptions);
    });
  });
});