// @ts-check
import { AccountApi } from './support/AccountApi.js';
import { DbClient } from './dbClient.js';
import logger from './support/logger.js';

/** @type {Record<string, import('./dbClient.js').DbClient>} key is the clusterId string, value the dbClient belonging to the clusterId */
const dbClientCache = {};
/** @type {DbClientSmacondi | null} */
let dbClientSmacondi = null;

/**
 * Gets a singleton dbClient instance, params are only needed during first call
 * @param {Object<string, string>} [connectionStringMap={}] - Object where key is the clusterId and value is the connection string for the cluster
 * @param {string} [apiURL='localhost:5000'] - URL of the account API to get account details
 * @param {number} [readTimeout=30000] - Read timeout in milliseconds
 * @param {number} [writeTimeout=30000] - Write timeout in milliseconds
 * @returns {DbClientSmacondi} - The singleton dbClientSmacondi instance
 * @throws {Error} - If params are missing during first call
 */
export function getDbClientSmacondi(connectionStringMap = {}, apiURL = 'localhost:5000', readTimeout = 30000, writeTimeout = 30000) {
  if (dbClientSmacondi === null) {
    logger.info('Creating new instance of DbClientSmacondi');
    dbClientSmacondi = new DbClientSmacondi(connectionStringMap, apiURL, readTimeout, writeTimeout);
  }
  return dbClientSmacondi;
}

/**
 * Closes all active database client connections
 * @returns {Promise<void>}
 */
export async function closeAllDbClients() {
  for (const dbClient of Object.values(dbClientCache)) {
    await dbClient.disconnect();
  }
}

/**
 * Private class to create only one instance
 */
class DbClientSmacondi {
  /**
   * Creates a new DbClientSmacondi instance
   * @param {Object<string, string>} connectionStringMap - Object where key is the clusterId and value is the connection string for the cluster
   * @param {string} [apiURL] - URL of the account API to get account details
   * @param {number} [readTimeout] - Read timeout in milliseconds
   * @param {number} [writeTimeout] - Write timeout in milliseconds
   * @throws {Error} - If connectionStringMap is empty, apiURL is invalid, or timeout values are not numbers
   */
  constructor(connectionStringMap, apiURL, readTimeout, writeTimeout) {
    // check connectionStringMap
    if (Object.keys(connectionStringMap).length === 0) {
      throw new Error(`Invalid connectionStringMap: ${connectionStringMap}`);
    } else {
      /** @type {Object<string, string>} */
      this.connectionStringMap = connectionStringMap;
    }
    // check apiUrl
    if (typeof apiURL !== 'string' || apiURL.trim() === '') {
      throw new Error(`Invalid apiURL: ${apiURL}`);
    } else {
      /** @type {AccountApi} */
      this.accountApi = new AccountApi(apiURL);
    }
    // check if read and write timeout are numbers
    if (typeof readTimeout !== 'number') {
      throw new Error(`Invalid read timeout: ${readTimeout}`);
    } else {
      /** @type {number} */
      this.readTimeout = readTimeout;
    }
    if (typeof writeTimeout !== 'number') {
      throw new Error(`Invalid write timeout: ${writeTimeout}`);
    } else {
      /** @type {number} */
      this.writeTimeout = writeTimeout;
    }
  }

  /**
   * Gets a dbClient instance which can connect to the account database and returns the name of the account database
   * @param {String} accountId - The ID of the account to get the database for
   * @returns {Promise<{ dbClient: import('./dbClient.js').DbClient, dbName: String, _id: String }>} - An object containing the dbClient, the db name, and the account id
   * @throws {Error} - If accountId is missing or no connection string is found for the cluster
   */
  async getDbClientByAccountId(accountId) {
    if (!accountId) {
      throw new Error('missing args');
    }
    const {
      clusterId,
      dbName
    } = await this.accountApi.getAccountById(accountId);
    const accountConnStr = this.connectionStringMap[clusterId];
    if (!accountConnStr) {
      throw new Error(`No connection string found for cluster ${clusterId}`);
    }
    let accountDbClient = dbClientCache[clusterId];
    if (!accountDbClient) {
      const newAccountDbClient = new DbClient(accountConnStr, this.readTimeout, this.writeTimeout);
      dbClientCache[clusterId] = newAccountDbClient;
      accountDbClient = newAccountDbClient;
    }
    return {
      dbClient: accountDbClient,
      dbName: dbName,
      _id: accountId
    };
  }

  /**
   * Returns the db client for the given clusterId
   * @param {string} [clusterId='MAIN'] - The ID of the cluster to get the client for
   * @returns {import('./dbClient.js').DbClient} - The database client for the specified cluster
   * @throws {Error} - If no connection string is found for the cluster
   */
  getDbClientByClusterId(clusterId = 'MAIN') {
    const connectionString = this.connectionStringMap[clusterId];
    if (!connectionString) {
      throw new Error(`No connection string found for cluster ${clusterId}`);
    }
    let dbClient = dbClientCache[clusterId];
    if (!dbClient) {
      dbClient = new DbClient(connectionString, this.readTimeout, this.writeTimeout);
      dbClientCache[clusterId] = dbClient;
    }
    return dbClient;
  }
}