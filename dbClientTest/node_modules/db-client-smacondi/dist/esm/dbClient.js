import { MongoClient, ObjectId } from 'mongodb';
import logger from './support/logger.js';
import DbOptimisticLock from './errors/dbOptimisticLock.js';
import lodashPkg from 'lodash';
const {
  isEqual
} = lodashPkg;
import { getMongoDbObjectId } from './support/utils.js';
import NotFound from './errors/notFound.js';
const READ_TIMEOUT = 30000;
const WRITE_TIMEOUT = 30000;

/** @typedef {import('mongodb').ClientSession} ClientSession */
/** @typedef {import('mongodb').ClientSessionOptions} ClientSessionOptions */
/** @typedef {import('mongodb').FindOptions} MongoOptions */
/** @typedef {import('mongodb').Filter<Document>} MongoQuery */
/** @typedef {import('mongodb').DeleteResult} DeleteResult */
/** @typedef {import('mongodb').WithId<Document>} DocumentWithId */

export class DbClient {
  /**
   * Creates an instance of the dbClient
   * @param {string} connectionString The connection string
   * @param {string|number} readTimeout Timeout in ms for read operations
   * @param {string|number} writeTimeout Timeout in ms for write operations
   */
  constructor(connectionString, readTimeout = READ_TIMEOUT, writeTimeout = WRITE_TIMEOUT) {
    this.connectionString = connectionString;
    if (!this.connectionString) {
      throw new Error('No connection string given to dbClient.');
    }
    this.readTimeout = this._getTimeout(readTimeout, READ_TIMEOUT);
    logger.info(`Set default query timeout in dbClient to ${this.readTimeout} ms.`);
    this.writeTimeout = this._getTimeout(writeTimeout, WRITE_TIMEOUT);
    logger.info(`Set default write timeout in dbClient to ${this.writeTimeout} ms.`);
  }

  /**
   * Connects to the MongoDB database
   */
  async connect() {
    this.client = await MongoClient.connect(this.connectionString, {
      maxPoolSize: 100,
      readPreference: 'secondaryPreferred'
    });
  }

  /**
   * Disconnects from the MongoDB database
   */
  async disconnect() {
    if (this.client) {
      await this.client.close(true);
      this.client = undefined;
    }
  }

  /**
   * Retrieves a single document matching the query
   * @param {String} dbName - Database name
   * @param {String} collectionName - Collection name
   * @param {MongoQuery} query - MongoDB query filter
   * @param {MongoOptions | undefined} options - MongoDB options
   * @returns {Promise<DocumentWithId | null>} - The found document or null if not found
   */
  async findOne(dbName, collectionName, query, options) {
    const collection = await this._getCollection(dbName, collectionName);
    return await collection.findOne(query, this._addOrCreateDefaultReadOptions(options));
  }

  /**
   * Retrieves a single document matching the query or throws an error if not found
   * @param {String} dbName - Database name
   * @param {String} collectionName - Collection name
   * @param {MongoQuery} query - MongoDB query filter
   * @param {MongoOptions | undefined} options - MongoDB options
   * @returns {Promise<DocumentWithId>} - The found document
   * @throws {NotFound} - If no document matches the query
   */
  async findOneOrThrow(dbName, collectionName, query, options) {
    const doc = await this.findOne(dbName, collectionName, query, options);
    if (doc) {
      return doc;
    }
    throw new NotFound('No record found');
  }

  /**
   * Finds a document matching the query and deletes it
   * @param {String} dbName - Database name
   * @param {String} collectionName - Collection name
   * @param {MongoQuery} query - MongoDB query filter
   * @param {MongoOptions | undefined} options - MongoDB options
   * @returns {Promise<import('mongodb').ModifyResult>} - The deleted document result
   */
  async findOneAndDelete(dbName, collectionName, query, options) {
    const collection = await this._getCollection(dbName, collectionName);
    return await collection.findOneAndDelete(query, this._addOrCreateDefaultReadOptions(options));
  }

  /**
   * Tries to find to document by given id
   * @param {String} dbName
   * @param {String} collectionName
   * @param {String | ObjectId} documentId
   * @param {*} options
   * @returns {Promise<DocumentWithId | null>} The document or null
   * @throws {Error} Throws error if documentId is not a valid MongoId
   */
  async findOneById(dbName, collectionName, documentId, options = undefined) {
    if (!documentId) {
      throw new Error('documentId not given');
    }

    // Special error logging because sometimes this methode is called with an invalid _id.
    let idAsObjectId;
    try {
      idAsObjectId = new ObjectId(documentId);
    } catch (error) {
      logger.error(`Invalid object id given to findOneById for db ${dbName}, collection ${collectionName}, documentId ${documentId}. Error: ${error.message}`);
      throw error;
    }
    const collection = await this._getCollection(dbName, collectionName);
    return await collection.findOne({
      _id: idAsObjectId
    }, this._addOrCreateDefaultReadOptions(options));
  }

  /**
   * Tries to find to document by given id or throws error if not found.
   * @param {String} dbName
   * @param {String} collectionName
   * @param {String | ObjectId} documentId
   * @param {*} options
   * @returns {Promise<DocumentWithId>} The document
   * @throws {NotFound} Throws error not found
   * @throws {Error} Throws error if documentId is not a valid MongoId
   */
  async findOneByIdOrThrow(dbName, collectionName, documentId, options = undefined) {
    const doc = await this.findOneById(dbName, collectionName, documentId, options);
    if (doc) {
      return doc;
    }
    throw new NotFound('No record found');
  }

  /**
   * Searches for documents matching the query
   * @param {String} dbName - Database name
   * @param {String} collectionName - Collection name
   * @param {MongoQuery} query - MongoDB query filter
   * @param {MongoOptions | undefined} options - MongoDB options
   * @returns {Promise<Array<DocumentWithId>>} - Array of matching documents
   */
  async find(dbName, collectionName, query, options) {
    const collection = await this._getCollection(dbName, collectionName);
    const cursor = collection.find(query, this._addOrCreateDefaultReadOptions(options));
    return await cursor.toArray();
  }

  /**
   * Searches for query and returns a cursor for the results
   * @param {String} dbName - Database name
   * @param {String} collectionName - Collection name
   * @param {MongoQuery} query - MongoDB query filter
   * @param {MongoOptions | undefined} options - MongoDB options
   * @returns {Promise<import('mongodb').FindCursor>} - Cursor for iterating through results
   */
  async findCursor(dbName, collectionName, query, options) {
    const collection = await this._getCollection(dbName, collectionName);
    return collection.find(query, this._addOrCreateDefaultReadOptions(options));
  }

  /**
   * Runs an aggregation pipeline
   * @param {String} dbName - Database name
   * @param {String} collectionName - Collection name
   * @param {Array} pipeline - MongoDB aggregation pipeline stages
   * @param {MongoOptions | undefined} options - MongoDB options
   * @returns {Promise<Array<Object>>} - Result documents from the aggregation
   * @throws {Error} - If the aggregation fails
   */
  async aggregate(dbName, collectionName, pipeline, options) {
    try {
      const collection = await this._getCollection(dbName, collectionName);
      const aggOptions = this._addOrCreateDefaultReadOptions(options);
      // Prior to mongo v6 the default of allowDiskUse was false. So we set this as a default value
      if (aggOptions.allowDiskUse == undefined) {
        aggOptions.allowDiskUse = false;
      }
      const cursor = collection.aggregate(pipeline, aggOptions);
      return await cursor.toArray();
    } catch (error) {
      logger.error(`Error during aggregation: ${error}. DB: ${dbName}, COLLECTION: ${collectionName}, PIPELINE: ${JSON.stringify(pipeline)}`);
      throw error;
    }
  }

  /**
   * Inserts one document into the collection
   * @param {String} dbName - Database name
   * @param {String} collectionName - Collection name
   * @param {Object} document - Document to insert
   * @param {MongoOptions} [options] - MongoDB options
   * @returns {Promise<import('mongodb').InsertOneResult>} - Result of the insert operation
   */
  async insertOne(dbName, collectionName, document, options) {
    const collection = await this._getCollection(dbName, collectionName);
    return await collection.insertOne(document, this._addOrCreateDefaultWriteOptions(options));
  }

  /**
   * Updates one document with a MongoDB update operation (e.g. $set)
   * @param {String} dbName - Database name
   * @param {String} collectionName - Collection name
   * @param {MongoQuery} filter - MongoDB query filter
   * @param {Object} update - MongoDB update operation (e.g., {$set: {field: value}})
   * @param {MongoOptions | undefined} options - MongoDB options
   * @returns {Promise<import('mongodb').UpdateResult<Document>>} - Result of the update operation
   */
  async updateOne(dbName, collectionName, filter, update, options) {
    const collection = await this._getCollection(dbName, collectionName);
    return await collection.updateOne(filter, update, this._addOrCreateDefaultWriteOptions(options));
  }

  /**
   * Replaces one document matched by filter with a new document
   * @param {String} dbName - Database name
   * @param {String} collectionName - Collection name
   * @param {MongoQuery} filter - MongoDB query filter
   * @param {Object} document - New document to replace with
   * @param {MongoOptions | undefined} options - MongoDB options
   * @returns {Promise<import('mongodb').UpdateResult<Document>>} - Result of the replace operation
   */
  async replaceOne(dbName, collectionName, filter, document, options) {
    const collection = await this._getCollection(dbName, collectionName);
    return await collection.replaceOne(filter, document, this._addOrCreateDefaultWriteOptions(options));
  }

  /**
   * Replaces one document by matching the _id of document
   * @param {String} dbName - Database name
   * @param {String} collectionName - Collection name
   * @param {Object} document - Document with _id to replace
   * @param {MongoOptions | undefined} options - MongoDB options
   * @returns {Promise<import('mongodb').UpdateResult<Document>>} - Result of the replace operation
   * @throws {Error} - If document has no _id
   */
  async replaceOneById(dbName, collectionName, document, options) {
    if (!document._id) {
      throw new Error('Document has no _id.');
    }
    const documentId = getMongoDbObjectId(document._id);
    const _document = structuredClone(document);
    delete _document._id;
    const collection = await this._getCollection(dbName, collectionName);
    return await collection.replaceOne({
      _id: documentId
    }, _document, this._addOrCreateDefaultWriteOptions(options));
  }

  /**
   * Replaces one document by id with version checking for optimistic locking
   * @param {String} dbName - Database name
   * @param {String} collectionName - Collection name
   * @param {Object} document - The document to save/replace (must contain _id and _v fields)
   * @param {MongoOptions | undefined} options - MongoDB options
   * @returns {Promise<import('mongodb').UpdateResult<Document>>} - The result of the mongo driver replaceOne method call if successful
   * @throws {Error} - If document has no _id or _v is not a number
   * @throws {DbOptimisticLock} - If version mismatch occurs or document doesn't exist
   */
  async replaceOneByIdWithVersionCheck(dbName, collectionName, document, options) {
    if (!document._id) {
      throw new Error('Document has no _id.');
    }
    if (typeof document._v !== 'number') {
      throw new Error('Document has no version or it is not of type number.');
    }
    const documentId = getMongoDbObjectId(document._id);
    delete document._id;

    // Increment version
    const currentDocumentVersion = document._v;
    document._v++;
    const collection = await this._getCollection(dbName, collectionName);
    const replaceResult = await collection.replaceOne({
      _id: documentId,
      _v: currentDocumentVersion
    }, document, this._addOrCreateDefaultWriteOptions(options));
    if (replaceResult.modifiedCount === 1) {
      return replaceResult;
    }
    throw new DbOptimisticLock('Version mismatch or document does not exist anymore.');
  }

  /**
   * Updates multiple documents matching the filter
   * @param {String} dbName - Database name
   * @param {String} collectionName - Collection name
   * @param {MongoQuery} filter - MongoDB query filter
   * @param {Object} update - MongoDB update operation
   * @param {MongoOptions | undefined} options - MongoDB options
   * @returns {Promise<import('mongodb').UpdateResult<Document>>} - Result of the update operation
   */
  async updateMany(dbName, collectionName, filter, update, options) {
    const collection = await this._getCollection(dbName, collectionName);
    return await collection.updateMany(filter, update, this._addOrCreateDefaultWriteOptions(options));
  }

  /**
   * Inserts multiple documents into the collection
   * @param {String} dbName - Database name
   * @param {String} collectionName - Collection name
   * @param {Array.<Object>} documents - Documents to insert
   * @param {MongoOptions | undefined} options - MongoDB options
   * @returns {Promise<import('mongodb').InsertManyResult<Document>>} - Result of the insert operation
   */
  async insertMany(dbName, collectionName, documents, options) {
    const collection = await this._getCollection(dbName, collectionName);
    return await collection.insertMany(documents, this._addOrCreateDefaultWriteOptions(options));
  }

  /**
   * Counts documents matching query - use for slow/precise counting
   * @param {String} dbName - Database name
   * @param {String} collectionName - Collection name
   * @param {MongoQuery} query - MongoDB query filter
   * @param {MongoOptions | undefined} options - MongoDB options
   * @returns {Promise<number>} - Count of matching documents
   */
  async count(dbName, collectionName, query, options) {
    const collection = await this._getCollection(dbName, collectionName);
    return collection.countDocuments(query, this._addOrCreateDefaultReadOptions(options)); // count()  is deprecated, see http://mongodb.github.io/node-mongodb-native/3.5/api/Collection.html#count
  }

  /**
   * Counts all documents in collection (no filter, estimated count) - use for fast counting
   * @param {String} dbName - Database name
   * @param {String} collectionName - Collection name
   * @param {MongoOptions | undefined} options - MongoDB options
   * @returns {Promise<number>} - Estimated count of documents in collection
   */
  async countEstimated(dbName, collectionName, options) {
    const collection = await this._getCollection(dbName, collectionName);
    return collection.estimatedDocumentCount(this._addOrCreateDefaultReadOptions(options));
  }

  /**
   * Gets distinct values of key from documents matching query
   * @param {String} dbName - Database name
   * @param {String} collectionName - Collection name
   * @param {String} key - Field name to get distinct values for
   * @param {MongoQuery} query - MongoDB query filter
   * @param {MongoOptions | undefined} options - MongoDB options
   * @returns {Promise<Array<any>>} - Array of distinct values
   */
  async distinct(dbName, collectionName, key, query, options) {
    const collection = await this._getCollection(dbName, collectionName);
    return await collection.distinct(key, query, this._addOrCreateDefaultReadOptions(options));
  }

  /**
   * Deletes many documents matching the query
   * @param {String} dbName
   * @param {String} collectionName
   * @param {MongoQuery} query
   * @param {MongoOptions} options
   * @returns {DeleteResult}
   */
  async deleteMany(dbName, collectionName, query, options) {
    const collection = await this._getCollection(dbName, collectionName);
    return await collection.deleteMany(query, this._addOrCreateDefaultWriteOptions(options));
  }

  /**
   * deletes one document from database
   * @param {String} dbName
   * @param {String} collectionName
   * @param {MongoQuery} query
   * @param {MongoOptions} options
   * @returns {DeleteResult} deletion result
   * @throws {Error} - deletion fails or no document found
   */
  async deleteOne(dbName, collectionName, query, options) {
    const collection = await this._getCollection(dbName, collectionName);
    return await collection.deleteOne(query, this._addOrCreateDefaultWriteOptions(options));
  }

  /**
   * deletes one document from database
   * @param {String} dbName
   * @param {String} collectionName
   * @param {String} documentId - _id of document
   * @param {MongoOptions} [options]
   * @returns {DeleteResult} deletion result
   */
  async deleteOneById(dbName, collectionName, documentId, options) {
    if (!documentId) {
      throw new Error('documentId not given');
    }
    const collection = await this._getCollection(dbName, collectionName);
    return await collection.deleteOne({
      _id: new ObjectId(documentId)
    }, this._addOrCreateDefaultWriteOptions(options));
  }

  /**
   * Creates a new collection if it doesn't already exist
   * @param {String} dbName - Database name
   * @param {String} collectionName - Collection name to create
   * @param {MongoOptions | undefined} options - MongoDB options
   * @returns {Promise<import('mongodb').Collection<Document> | undefined>} - Created collection or undefined if it already exists
   */
  async createCollection(dbName, collectionName, options) {
    const exists = await this.existsCollection(dbName, collectionName);
    if (exists) {
      return;
    }
    const db = await this._getDb(dbName);
    return await db.createCollection(collectionName, this._addOrCreateDefaultWriteOptions(options));
  }

  /**
   * Drops a collection if it exists
   * @param {String} dbName - Database name
   * @param {String} collectionName - Collection name to drop
   * @param {MongoOptions | undefined} options - MongoDB options
   * @returns {Promise<boolean | undefined>} - True if successful, undefined if collection doesn't exist
   */
  async dropCollection(dbName, collectionName, options) {
    const exists = await this.existsCollection(dbName, collectionName);
    if (!exists) {
      return;
    }
    const db = await this._getDb(dbName);
    return await db.dropCollection(collectionName, this._addOrCreateDefaultWriteOptions(options));
  }

  /**
   * @typedef {Object} IndexDefinition
   * @property {String} name
   * @property {Object} definition
   * @property {Object} mappings - see mongo docs https://www.mongodb.com/docs/atlas/atlas-search/create-index/
   */

  /**
   * @param {String} dbName
   * @param {String} collectionName
   * @param {IndexDefinition} indexDefinition
   */
  async createOrUpdateSearchIndex(dbName, collectionName, indexDefinition) {
    const collection = await this._getCollection(dbName, collectionName);
    const searchIndexes = await collection.listSearchIndexes().toArray();
    const currentIndex = searchIndexes.find(searchIndex => searchIndex.name === indexDefinition.name);
    if (!currentIndex) {
      return await collection.createSearchIndex(indexDefinition);
    }
    if (isEqual(currentIndex.latestDefinition, indexDefinition.definition)) {
      return;
    }
    return await collection.updateSearchIndex(indexDefinition.name, indexDefinition.definition);
  }

  /**
   *
   * @param {string} dbName
   * @param {string} collectionName
   * @returns {Promise<import('mongodb').IndexDescriptionInfo[]>}
   */
  async getAllIndex(dbName, collectionName) {
    const collection = await this._getCollection(dbName, collectionName);
    return await collection.indexes();
  }
  async createIndex(dbName, collectionName, field, options) {
    const collection = await this._getCollection(dbName, collectionName);
    return await collection.createIndex(field, this._addOrCreateDefaultWriteOptions(options));
  }
  async dropIndex(dbName, collectionName, indexName, options) {
    const collection = await this._getCollection(dbName, collectionName);
    return await collection.dropIndex(indexName, this._addOrCreateDefaultWriteOptions(options));
  }

  /**
   * Runs a MongoDB command directly on the database
   * @param {String} dbName - Database name
   * @param {Object} command - MongoDB command document
   * @returns {Promise<any>} - Command result
   */
  async runCommand(dbName, command) {
    const db = await this._getDb(dbName);
    return await db.command(command);
  }

  /**
   * Gets a list of all database names
   * @returns {Promise<Array<string>>} - List of database names
   */
  async getDbNames() {
    const db = await this._getDb('test');
    const result = await db.admin().listDatabases({
      nameOnly: true
    });
    return result.databases.map(r => r.name);
  }

  /**
   * Checks if a database exists
   * @param {String} dbName - Database name to check
   * @returns {Promise<boolean>} - True if database exists
   * @throws {Error} - If dbName is empty
   */
  async existsDb(dbName) {
    if (!dbName) {
      throw new Error('empty argument dbName');
    }
    const dbNames = await this.getDbNames();
    return dbNames.map(n => n.toLowerCase()).includes(dbName.toLowerCase());
  }

  /**
   * Lists all collections in a database
   * @param {String} dbName - Database name
   * @returns {Promise<Array<string>>} - List of collection names
   * @throws {Error} - If dbName is empty
   */
  async listCollections(dbName) {
    if (!dbName) {
      throw new Error('empty argument dbName');
    }
    const db = await this._getDb(dbName);
    return (await db.listCollections({}, {
      nameOnly: true
    }).toArray()).map(c => c.name);
  }

  /**
   * Checks if a collection exists in a database
   * @param {String} dbName - Database name
   * @param {String} collectionName - Collection name to check
   * @returns {Promise<boolean>} - True if collection exists
   * @throws {Error} - If dbName or collectionName is empty
   */
  async existsCollection(dbName, collectionName) {
    if (!dbName || !collectionName) {
      throw new Error('empty argument');
    }
    const db = await this._getDb(dbName);
    const collections = await db.listCollections({
      name: collectionName
    }, {
      nameOnly: true
    }).toArray();
    return collections.length === 1;
  }

  /**
   * Checks if the given value is unique in the collection.
   * If _id is given and matches the found document the value is considered unique.
   * Attention: The code assumes that the existing values in the DB are already unique!
   * @param {String} dbName - Database name
   * @param {String} collectionName - Collection name
   * @param {String} fieldName - The field name to check
   * @param {any} value - The value to check for uniqueness
   * @param {import('mongodb').ObjectId | String} [_id] - Optional document ID
   * @returns {Promise<boolean>} - True if the value is unique, false otherwise
   * @throws {Error} - If fieldName or value is missing
   */
  async isUnique(dbName, collectionName, fieldName, value, _id = undefined) {
    if (fieldName == null || fieldName === '') {
      throw new Error('fieldName is missing');
    }
    if (value == null) {
      throw new Error('value is missing');
    }
    const document = await this.findOne(dbName, collectionName, {
      [fieldName]: value
    }, {
      projection: {
        _id: 1
      }
    });
    return document == null || document._id.equals(_id);
  }

  /**
   * Gets a MongoDB collection instance
   * @param {String} dbName - Database name
   * @param {String} collectionName - Collection name
   * @returns {Promise<import('mongodb').Collection>} - MongoDB collection instance
   * @throws {Error} - If dbName or collectionName is empty
   * @private
   */
  async _getCollection(dbName, collectionName) {
    if (!dbName || !collectionName) {
      throw new Error('empty argument');
    }
    const db = await this._getDb(dbName);
    return db.collection(collectionName);
  }

  /**
   * Gets a MongoDB database instance
   * @param {String} dbName - Database name
   * @returns {Promise<import('mongodb').Db>} - MongoDB database instance
   * @throws {Error} - If dbName is empty
   * @private
   */
  async _getDb(dbName) {
    if (!dbName) {
      throw new Error('empty dbName');
    }
    if (!this.client) {
      await this.connect();
    }
    return this.client.db(dbName);
  }

  /**
   * Gets a valid timeout value
   * @param {string|number} value - Timeout value to validate
   * @param {number} defaultTimeout - Default timeout to use if value is invalid
   * @returns {number} - Valid timeout value
   * @private
   */
  _getTimeout(value, defaultTimeout) {
    const timeout = +value;
    return timeout > 0 ? timeout : defaultTimeout;
  }

  /**
   * Adds default write timeout settings to MongoDB options
   * @param {MongoOptions | undefined} options - Original options
   * @returns {MongoOptions} - Options with write timeout settings
   * @private
   */
  _addOrCreateDefaultWriteOptions(options) {
    let opt = options; // this will change the state of the object but I think it is ok, so no deep clone
    if (opt == null) {
      opt = {
        writeConcern: {
          wtimeout: this.writeTimeout
        }
      };
    } else if (opt.writeConcern == null) {
      opt.writeConcern = {
        wtimeout: this.writeTimeout
      };
    } else if (opt.writeConcern.wtimeout == undefined || opt.writeConcern.wtimeout <= 0) {
      opt.writeConcern.wtimeout = this.writeTimeout;
    }
    return opt;
  }

  /**
   * Adds default read timeout settings to MongoDB options
   * @param {MongoOptions | undefined} options - Original options
   * @returns {MongoOptions} - Options with read timeout settings
   * @private
   */
  _addOrCreateDefaultReadOptions(options) {
    let opt = options; // this will change the state of the object but I think it is ok, so no deep clone
    if (opt == null) {
      opt = {
        maxTimeMS: this.readTimeout
      };
    } else if (opt.maxTimeMS == undefined || opt.maxTimeMS <= 0) {
      opt.maxTimeMS = this.readTimeout;
    }
    return opt;
  }

  /**
   * Processes documents in batches to avoid memory issues with large result sets
   * @param {String} dbName - Database name
   * @param {String} collectionName - Collection name
   * @param {MongoQuery} query - MongoDB query filter
   * @param {MongoOptions | undefined} options - MongoDB options
   * @param {number} batchSize - Size of each batch to process
   * @param {function(Array<Object>): Promise<void>} actionCallback - Callback function to process each batch
   * @returns {Promise<number>} - Total number of documents processed
   * @deprecated This method is deprecated and will be removed, switch to "findByBatchWithCallback"
   */
  async batchAction(dbName, collectionName, query, options, batchSize, actionCallback) {
    let documentsCount = 0;
    while (true) {
      const resultBatch = await this.find(dbName, collectionName, query, {
        limit: batchSize,
        skip: documentsCount,
        ...options
      });
      if (resultBatch.length > 0) {
        await actionCallback(resultBatch);
      }
      documentsCount += batchSize;
      if (resultBatch.length < batchSize) {
        break;
      }
    }
    return documentsCount;
  }

  /**
   * Processes documents in batches to avoid memory issues with large result sets
   * @param {String} dbName - Database name
   * @param {String} collectionName - Collection name
   * @param {MongoQuery} query - MongoDB query filter
   * @param {MongoOptions | undefined} options - MongoDB options
   * @param {number} batchSize - Size of each batch to process
   * @param {function(Array<Object>): Promise<void>} actionCallback - Callback function to process each batch
   * @returns {Promise<number>} - Total number of documents processed
   */
  async findByBatchWithCallback(dbName, collectionName, query, options, batchSize, actionCallback) {
    let documentsCount = 0;
    while (true) {
      const resultBatch = await this.find(dbName, collectionName, query, {
        limit: batchSize,
        skip: documentsCount,
        ...options
      });
      if (resultBatch.length > 0) {
        await actionCallback(resultBatch);
      }
      documentsCount += batchSize;
      if (resultBatch.length < batchSize) {
        break;
      }
    }
    return documentsCount;
  }

  /**
   * Executes operations within a MongoDB transaction
   * @param {function(ClientSession): Promise<void>} callback - Function to execute within the transaction
   * @param {ClientSessionOptions} sessionOptions - Options for the session
   * @param {Object} transactionOptions - Options for the transaction
   * @returns {Promise<void>}
   * @throws {Error} - Logs errors but doesn't rethrow them
   */
  async inTransaction(callback, sessionOptions = {}, transactionOptions = undefined) {
    const _transactionOptions = transactionOptions ?? {
      readPreference: 'primary'
    };
    const clientSession = this.client.startSession(sessionOptions);
    logger.info('Start transaction session');
    try {
      await clientSession.withTransaction(async session => {
        await callback(session);
      }, _transactionOptions);
    } catch (e) {
      logger.error(e);
    } finally {
      await clientSession.endSession();
      logger.info('Transaction session finished');
    }
  }

  /**
   * Starts a mongodb session & returns it
   * @param {ClientSessionOptions} sessionOptions
   * @returns {ClientSession}
   */
  startSession(sessionOptions = {}) {
    return this.client.startSession(sessionOptions);
  }
}